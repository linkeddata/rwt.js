var http = require('http');
var url = require('url');
var crypto = require('crypto');

baseurl = (function() {
    //var key = crypto.randomBytes(2).toString('hex'),
    var key = '1234',
        base = 'http://test'+key+'.data.fm';
    return function(path) { return url.parse(base + path); }
})();

exports.req = function(options, callback) {
    var s = 0, h = {}, d = '';
    if (options.path[0] == '/') {
        q = baseurl(options.path);
        for (k in options)
            if (options.hasOwnProperty(k) && k != 'path')
                q[k] = options[k];
    } else q = options;
    var q = http.request(q, function(r) {
        s = r.statusCode;
        h = r.headers;
    }).on('response', function(response) {
        response.on('data', function(s) {
            d += s;
        }).on('error', function(e) {
            console.log("req.error: " + e.message);
        }).on('close', function(e) {
            console.log('close.error: ' + e);
            if (callback)
                callback({status:s, headers:h, data:d, error:e});
        }).on('end', function() {
            if (callback)
                callback({status:s, headers:h, data:d});
        });
    });
    if (options.data)
        q.write(options.data);
    q.end();
    return q;
};

exports.matchtest = function(test, s, p) {
    return test.ok(s.match(p), 'match(' + p.toString() + ') failed on: ' + s.toString());
}

